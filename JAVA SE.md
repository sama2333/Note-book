# 基础语法
## 注释
单行注释：
```
//...
```
多行注释：
```
/* .. */
```
文档注释：
```
/** ... */
```
文档注释内容可提取至程序说明书中去

## 字面量
目的：展示数据的书写方式
整数、小数：与正常书写无异
字符：程序中要用单引号围起来，里面只能存放一个字符
字符串：用双引号围起来，里面内容随意
布尔值：false、true
空值：null

## 变量
作用：内存中的一块区域，里面可以储存一个数据，存储的数据可以变化
格式：
```
数据类型 变量名称 = 初始值;
```
赋值：从右往左执行
##### 注意事项
1、变量使用前需要声明
2、某种类型的变量只能存储该类型的数据
3、变量从定义开始到}结束，同一个有效范围内不能定义同名的变量
4、变量定义时可以没有初始值，但使用时必须有初始值

变量存储的是数据的二进制模式，文字存储的是ASCII编码中的对应数字的二进制形式

## 二进制转换
转换为十进制：
```
1001--》1*2^0+0*2^1+0*2^2+1*2^3 = 9
```
转换为八进制：
```
01011101 --> 01|011|101 -->135
```
转换为十六进制：
```
01011101 --> 0101|1101 -->5D
```

## 数据类型
作用：约束变量只能存储某种类型的数据，帮助定义不同类型的变量
##### 数据类型分类：
字节整型：byte（内存占1个字节，范围：-128~127）
短整型：short（2个字节）
默认整型：int（4个字节）
长整型：long（8个字节）
单精度浮点型：float（4个字节）
双精度浮点型：double（8个字节）
字符型：char（2个字节）
布尔型：boolean（1个字节）
##### 注意事项：赋值long时数字后面加上L/l;赋值float时数字后加上F/f

## 关键字、标识符
关键字：Java自己使用的变量
标识符：不能数字开头、不可使用关键字、区分大小写

## 类型转换
### 自动类型转换
原理：小范围类型变量直接赋值给大范围类型变量
范围：
```
byte-->short-->int-->long-->float-->double
        char-->
```
### 表达式的自动类型转换
含义：在表达式中，小范围类型变量会自动转换为大范围类型变量
结论：表达式的最终结果的数据类型是由表达式内最大范围类型变量决定
注意：byte、short、char在表达式中会被强制转换为int进行运算

### 强制类型转换
含义：大范围类型的变量不能直接赋值给小范围类型的变量，否则会报错，必须进行强制类型转换
格式：
```
数据类型 变量 = (数据类型)其他数据类型的变量/数据
```
##### 注意：
强制类型转换会出现数据丢失/数据溢出
浮点型数据强制转换为整型，会保留整数部分，小数部分直接清除

## 运算符
### 基本运算符
```
常见运算符：+ - * / %
```
##### 注意：两个整数相除必定是整数
```
10/3 == 3
1.0*10/3 == 3.3333
```
### +符号做连接符
+符号与字符串类型数据进行计算时，充当连接符，连接的结果仍是字符串

### 自增自减运算符
++：对变量进行+1操作
--：对变量进行-1操作
##### 注意：++、--放在变量前面，先+1、-1再使用变量，若放在变量之后，则先使用变量再+1、-1

### 赋值运算符
=、+=、-=、*=、/=、%=
```
a += b
等价于
a = (a的类型)(a + b)
```
用处：用于做数据的累计操作,并且自带强制类型转换操作

### 关系运算符
```
== != > >= < <=
```
判断是否满足条件，返回true或false

### 逻辑运算符
```
& && | || ! ^
```
单符号和双符号的区别在于双符号若前面条件被满足则直接中止操作
&(&&)：前后皆为true，才能返回true，若有一个为false，则返回false
|(||)：只要有一个为true，就能返回true，只有前后皆为false，才返回false
!：取反操作，!false = true !true = false
^ 异或操作：前后一样返回true，前后不一致则返回false

### 三元运算符
作用：用做分支选择
```
条件表达式? 值1: 值2;
```

### 运算符优先级
运算符存在谁先谁后执行的情况
()优先级最高
*/高于+-
&&高于||

# 键盘录入技术
```java
//导包（自动导入）
import java.util.Scanner;
//创建扫描器对象
Scanner sc = new Scanner(System.in);
//等待接收用户数据
int age = sc.nextint();
//等待接受用户数据
String name = sc.next();
```

# 程序流程控制

## 顺序结构

## 分支结构
### if：通过判断条件来决定执行哪个分支
三种格式：
```java
if(条件表达式){
    语句体;
}

if(条件表达式){
    语句体1;
}else{
    语句体2;
}

if(条件表达式1){
    语句体1;
}else if(条件表达式2){
    语句体2;
}else if(条件表达式3){
    语句体3;
}
...
else{
    语句体n+1;
}
```

### switch：通过表达式的值进行匹配选择对应分支执行
```java
switch(表达式){
    case 值1:
        执行代码1;
        break;
    case 值2:
        执行代码2;
        break;
    case 值3:
        执行代码3;
        break;
    default:
        执行代码m;
}
```
##### 注意
switch 语句中的变量类型可以是： byte、short、int 或者 char。从JDK5开始支持枚举。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。
case给出的值不允许重复，且只能为字面量，不能为变量。
若没有添加break，会出现穿透现象。即按顺序继续执行下一个case中语句，直至结束或遇break。

## 循环结构
作用：控制一段代码重复多次执行
### for循环
```java
for(初始化语句;循环条件;迭代语句) {
    循环体语句;
}
//实例
for(int i = 0;i<10;i++) {
    System.out.println("Hello,World");
}
```

### while循环
```java
while(循环条件){
    循环体语句;
    迭代语句;
}
```

### do-while循环
```java
do{
    循环体语句;
    迭代语句;
}while(循环条件);
```

##### 注意
for和while先判断条件再执行，do-while必定先执行一次循环语句再判断条件。
一开始知道循环次数优先使用for循环，不知道循环的次数优先使用while循环。

## 死循环
```java
for(;;) {
    System.out.println("Hello,World");
}

while(true){
    System.out.println("Hello,World");
}

do{
    System.out.println("Hello,World");
}while(true);
```


## 跳转关键字
### break
跳出并结束当前所在的循环
只能用在结束所在循环或结束switch分支的执行
### continue
用于跳出当前循环的当次执行，进入下一次循环
只能在循环中使用

## 随机数Random类
作用：产生随机数
```java
//导包
import java.util.Random;
//创建随机数对象
Random r = new Random();
//开始得到随机数
int data = r.nextint(10);//0-9
```

# 数组
## 作用
数组是一个容器，用于存放一批同类型的数据

## 定义
### 静态初始化数组
```java
数据类型[] 数组名称 = new 数据类型[]{元素1,元素2,元素3,...};
数据类型[] 数组名称 = {元素1,元素2,元素3,...};
```
特点：在创建数组时为数组确定数据

### 动态初始化数组
```
数据类型[] 数组名称 = new 数据类型[长度];
```
特点：确定数组的类型和长度
动态初始化数组中元素存在默认值：
byte,short,char,int,long----0
float,double-----0.0
boolean-----false
类,接口,数据,String------null
## 数组的访问
```java
//格式：
数组名称[索引]
//取值：
int data = arr[1];
//赋值：
arr[1] = 222;
//长度：
arr.length()
```
##### 注意
1、某种类型的数组只能存放该类型的数据
2、数据类型[] 数组名称 和 数据类型 数组名称[] 是等价的，没有错误的
3、数组一旦定义，程序执行的过程中，该数组的类型和长度就固定不可修改

## 数组的遍历
一个一个的访问每一个数据
例子：
```java
int[] ages = {20,30,40,50};
for(int i = 0;i<ages.length;i++){
    System.out.println(ages[i]);
}
```

## 数组的内存图
Java的内存分配
方法区：放Class文件
栈内存：运行的方向，main方法，定义的变量
堆内存：new出来的对象，都在堆内存

## 数组使用的常见问题
不要访问超过数组最大索引——否则出现数组访问越界异常
空指针异常问题：
```
int[] arr = null;
System.out.println(arr);//null
System.out.println(arr.length);//空指针异常
```

# 方法
作用：封装一段代码的语法结构，可以被重复调用，以此提高代码的复用性，提高开发效率。

## 方法的完整定义格式
```java
修饰符 返回值类型 方法名(形参列表){
    方法体代码;
    return 返回值;
}
```

### 不带返回值的方法

定义格式

```java
修饰符 void 方法名(形参列表){
    方法体;
}
```

## 方法的调用
方法要发挥作用必须要被调用
​	直接调用：执行方法，但不管返回值
```java
方法名(实参);
```

​	赋值调用:定义变量来接收返回值
```java
整数类型 变量名 = 方法名(实参);
```

​	输出调用:在输出语句中调用方法
```java
System.out.println(方法名(实参))
```
## 方法注意事项

1、方法不调用就不执行
2、方法与方法之间是平级关系,不能相互嵌套
3、方法的编写顺序和执行顺序无关
4、方法的返回值为void类型,没有返回值,可以忽略return语句,如果写return则后面不能跟具体数据
5、return语句下面不能编写代码,因为永远执行不到,属于无效代码

## 方法的参数传递机制
值传递：传输的不是实参本身，而是实参的值的副本
无论是基本数据类型还是引用数据类型的参数，都是满足值传递，前者传递的数据，后者传递的是存储的地址的值

## 方法的重载

定义:在同一个类中,方法名相同,参数不同的方法,与返回值无关
参数不同: 个数不同、类型不同、顺序不同
tips:顺序不同可以构成重载,但是不建议

## return关键字

方法没有返回值:可以省略不写,如要书写,表示结束方法
方法有返回值:必须要写,表示结束方法和返回结果


# 面向对象
##### 含义：拿东西来解决问题

## 类和对象

类:对象共同特征的描述
对象:真实存在的具体东西
##### 注意：在java中必须先设计类再创建对象

## 定义类
```java
public class 类名 {
    1.成员变量(代表属性,一般是名词)
    2.成员方法(代表行为,一般是动词)
    3.构造器
    4.代码块
    5.内部类
}
```
##### 注意事项:
类名书写方式:大驼峰命名法
一个文件只能定义一个由public修饰的类，并且类名必须是Java代码文件的名称
### 具体例子：
```java
public class Car{
    //成员变量
    String name;
    double price;
    //成员方法
    public void start(){
        System.out.println(name+"价格是"+price+"启动成功");
    }

    public void run(){
        System.out.println(name+"价格是"+price+"跑起来了");
    }

}
```
## 创建对象

```java
类名 对象名 = new 构造器();
```

## 构造器
作用：初始化一个类的对象，并返回该对象的地址
格式：
```java
修饰符 类名(形参){  }
```
### 构造器分类
1、无参构造器，初始化的对象中存储的是默认值。
2、有参构造器，初始化的对象中可以存储指定值。

##### 注意：
任意类创建的时候都会自带一个无参构造器，当在该类中创建了一个有参构造器，自带的无参构造器会消失，若要使用无参构造器，必须重新定义一个无参构造器。

## this关键字
表示当前方法调用者的地址值
就近原则:谁离我近,我就用谁
this关键字直接使用成员变量
格式:

```java
this.成员变量名;
```

## 封装
面向对象的三大特征之一
如何正确设计对象的属性和方法
原则:对象代表什么,就得封装对应的数据,并提供数据对应的行为
建议：
成员变量private私有化，只能本类访问
要为成员变量提供get和set方法来暴露取值和赋值

## 标准JavaBean类（实体类）

1. 类名需要见名知意
2. 成员变量使用private修饰
3. 提供至少两个构造方法
   - 空参构造
   - 全参构造
4. 成员方法
   - 每一个成员的setXxx()和getXxx()方法
   - 其他方法

## 成员变量和局部变量的区别
成员变量:类中方法外的变量
局部变量:方法中的变量


# API
API:应用程序编程接口;别人已经写好的东西
Scanner:读取键盘输入
Random:随机数

## API帮助文档
帮助开发人员使用和查询API的工具

## 使用帮助文档
1. 在搜索框中查询
2. 查看类所在的包
3. 查看类的描述
4. 查看构造方法
5. 查看成员方法

# String

在java.lang.String中
所有字符串都是String类型
字符串的内容不会发生改变,它的对象在创建后不能被更改

## 创建String对象的两种方式

1. 直接赋值

```java
String name = "";
```

2. new

| 构造方法                       | 说明                            |
| ------------------------------ | ------------------------------- |
| public String()                | 创建空白字符串,不含任何内容     |
| public String(String original) | 根据传入的字符串,创建字符串对象 |
| public String(char[] chars)    | 根据字符数组,创建字符串对象     |
| public String(byte[] bytes)    | 根据字节数组,创建字符串对象     |

直接赋值的对象存在堆内存的常量池中，同一个内容只存储一次。
new字符串对象，每new一次的都会在堆内存中产生一个字符串对象。

### 比较

`==`:
- 基本数据类型:比较的是具体的值
- 引用数据类型:比较的是地址值

比较方法:
- boolean equals(要比较的字符串):完全一致
- boolean equalsIgnoreCase(要比较的字符串):忽略大小写

# ArrayList集合

长度可变的容器(自动扩容)
集合容器中存储的是对象中堆内存的地址

### 泛型
限定集合中存储数据的类型

```java
方法<数据类型>
```

##### 特点:
- 不能存基本数据类型,只能存引用数据类型或包装类
- 长度可变

## 构建方法
```java
public ArrayList();

ArrayList arr = new ArrayList();
```

## 成员方法
```java
//在指定位置插入指定元素，默认在集合末尾添加
public boolean add(int index,E element);
//删除索引处的元素，并返回该元素
public E remove(int index);
//删除指定的元素，并返回是否成功
public boolean remove(Oject o);
//修改指定索引处元素，并返回被修改的元素
public E set(int index,E element);
//返回指定索引处的元素
public E get(int index);
//返回集合中元素的个数
public int size();
```
### 遍历并删除元素
应当从末端往前遍历，边遍历边删除。


# static关键字
表示静态,是java中的修饰符,可以修饰成员方法,成员变量。

## 静态变量
static修饰的成员变量
特点:
- 被该类所有对象共享
- 不属于对象,属于类
- 随着类的加载而加载的,优先于对象出现
- 该变量在内存中只有一份

调用方式
- 使用类名调用(推荐)
- 使用对象名调用

## 静态方法
static修饰的成员方法

特点:
- 多用在测试类和工具类中
- Javabean类很少会用

调用方式:
- 使用类名调用(推荐)
- 使用对象名调用

## 工具类
帮助我们做一些事情,但是不描述任何事物的类。
##### 注意
- 工具类的构造器应该私有化
- 工具类里面都是静态方法。


Javabean类:用来描述一类事物的类

测试类:用来检查其他类是否书写正确,带有main方法的类,是程序的入口

遵守的规则:
- 类名见名知意
- 私有化构造方法->外界无法创建这个对象->原因:创建这个对象无意义
- 方法

#### 注意事项
- 静态方法**只能**访问静态变量和静态方法
- 非静态方法**可以**访问静态变量或者静态方法,**也可以**访问非静态的成员变量和非静态的成员方法
- 静态方法中没有this关键字

### 静态代码块
格式：
```java
static{
    代码段;
}
```
属于类，与类一起加载，自动触发并执行一次

## 单例
单例是一种设计模式，是为了解决某一个问题
单例解决：保证每个类对外只产生一个对象

### 饿汉单例
当需要使用对象的时候，对象已经被创建
实现步骤：
- 构造器私有
- 定义静态成员变量存储一个对象

例子：
```java
public class SingleInstance {
    //定义一个静态变量并创建了一个对象
    public static SingleInstance instance = new SingleInstance();
    //构造器私有化
    private SingleInstance(){
    }
}
```

### 懒汉单例
当需要使用对象的时候才开始创建一个对象
实现步骤：
- 构造器私有
- 定义静态成员，暂时不存储对象

例子：
```java
public class SingleInstance {
    //定义一个静态变量
    public static SingleInstance instance;
    //提供一个方法，对外返回单例对象
    public static SingleInstance getInstance() {
        if(instance == null){
            //只有在第一次使用对象的时候才需要创建对象
            instance  = new SingleInstance();
        }
    }
    //构造器私有化
    private SingleInstance(){
    }

}
```

# 继承
Java中提供一个关键字`extends`,用这个关键字,可以让一个类和另一个类建立起继承关系
### 格式：
```java
//Student称为子类
//Person称为父类
public class Student extends Person{}
```
### 特点:
- 提高代码的复用性
- 子类可以在父类基础上增加其他的功能

### 继承的设计规范
子类共用的属性和行为放在父类，子类独有的属性和行为放在子类自己那里。

### 继承的特点
- 子类可以继承父类的属性和行为
- 子类可以继承父类的私有成员，但不能直接打开
- 子类没有继承父类的静态成员，但可以直接打开
- Java是单继承模式：每个类只能继承一个直接父类
- Java不支持多继承，但支持多层继承
- Java中所有类都是Object类的子类

## 继承后

### 成员变量和方法的访问特点
- 就近原则：谁离我近,我就用谁
- this.子类自己的成员变量
- super.父类的成员变量或方法

### 方法重写
当父类的方法不能满足子类现在的需求时,需要进行方法重写

书写格式:在继承体系中,子类出现了和父类中一模一样的方法声明,我们就称子类这个方法是重写的方法

`@Override` 重写注解

1. `@Override`是放在重写后的方法上,校验子类重写时语法是否正确
2. 加上注解后如果有红色波浪线,表示语法错误
3. 建议重写方法都加`@Override`注解,代码安全,优雅

重写的本质:子类发生了重写,会在虚方法表中覆盖父类的虚方法

​	要求:

- 重写的方法的名称、形参列表必须与父类中的一致
- 子类重写父类方法时,访问权限子类必须大于等于父类
- 子类重写父类方法时,返回值类型子类必须小于等于父类
- 建议:重写的方法尽量和父类保持一致
- 只有被添加到虚方法表中的方法才能被重写

小技巧:

- 如果重写的方法需要在父类的基础上进行,那么可以调用父类的方法`super.方法名()`

### 子类构造方法的访问特点

- 父类的构造方法不会被子类继承

- 子类中所有的构造方法默认先访问父类中的无参构造,再执行自己

  > 子类初始化之前,一定要调用父类构造方法先完成父类数据空间的   初始化

- 子类构造方法的**第一行**语句默认都是:super(),不写也存在,且**必须在第一行**

- 如果想调用父类有参构造,必须手动写super进行调用

### this,super使用总结

this:理解成一个变量,表示当前方法调用者的地址值

super:代表父类存储空间

this调用构造方法:调用本类其他构造方法

> 比如空参构造里面用this调用全参构造


# 包
包是用来分类管理不同类的，类似于文件夹的管理，建包利于程序的管理和维护
格式：
```java
package com.tan.javabean;
public class Student{

}
```
建包语句一般在第一行

## 导包
相同包下的类可以直接访问，不同包下的类必须导包，才可使用
导包格式：
```java
import 包名.类名;
```
假如一个类中需要用到另两个类，并且两个类同名，那么默认只能导入一个类，另一个类需要带包名来进行访问

# 权限修饰符
- 用来控制一个成员能够被访问的范围

- 可以修饰成员变量,方法,构造方法,内部类

分类:

范围从小到大(private<空着不写(缺省/默认)<protected<public)

| 修饰符    | 同一个类 | 同一个包其他类 | 不同包子类 | 不同包无关类 |
| --------- | -------- | -------------- | ---------- | ------------ |
| private   | √        |                |            |              |
| 默认      | √        | √              |            |              |
| protected | √        | √              | √          |              |
| public    | √        | √              | √          | √            |

实际开发中:只用private和public

- 成员变量私有

- 方法公开

  > 如果方法中的代码是抽取其他方法中共性代码,这个方法一般也私有


# final关键字

修饰符:不可改变，表示最终的意思

- 方法:不能被重写
- 类:不能被继承
- 变量:只能赋值一次(第一次必须赋值)

常量:

一般作为系统的配置信息,方便维护,提高可读性

规范:

- 单个单词:全部大写
- 多个单词:全部大写,单词之间用下划线隔开

细节:

- final修饰的变量是基本变量:数据值不变
- final修饰的变量是引用变量:地址值不变,内部的属性值还是可以改变的

# 常量
- 常量是使用了public static final 修饰的成员变量，必须有初始化值，且代码执行过程中值不能改变
- 作用和好处：可以作为配置信息
- 命名规范；英文字母全部大写，多个单词用下划线连接

## 执行原理
- 在编译阶段会进行“宏变换”，把使用常量的地方全部替换成真实的字面量

# 枚举
- 作用：信息的标志及分类
格式：
```java
修饰符 enum 枚举名称{
    第一行都是罗列枚举实例的名称;
}
```

# 抽象类

- 抽象方法:
  - 将**共性的方法**抽取到父类之后,
  - 由于每一个子类执行的内容是不一样的,所以,在父类中**不能确定具体的方法体**
- 抽象类:
  - 类中存在**至少一个**抽象方法
  - 该类必须声明为抽象类
- 抽象方法子类必须**重写所有抽象方法**才能创建对象
- 顶层父类如果**无需创建对象**,可以使用abstract修饰

格式

```java
//抽象方法
public abstract 返回值类型 方法名(参数列表);
//抽象类
public abstract class 类名{}
```

注意事项:

- 抽象类不能实例化(创建对象)

- 抽象类中不一定有抽象方法,有抽象方法的类一定是抽象类

- 抽象类可以有构造方法

  > 创建子类对象时,给子类中父类的私有属性进行赋值

- 抽象类的子类

  - 重写所有的抽象方法
  - 也是一个抽象类
- 不能用abstract修饰变量、代码块、构造器
意义:统一子类中方法的名称

# 接口

就是一种规则,对行为的抽象

- 定义:

```java
public interface 接口名 {}
```

## 实现类

```java
public class 类名 implements 接口名 {}
```

- 接口不能实例化
- 接口的子类(实现类)
  - 要么重写接口中所有抽象方法
  - 要么是抽象类

注意:

- 接口可以单实现,也可以多实现

```java
public class 类名 implements 接口名1, 接口名2 {}
```

- 实现类还可以在继承一个类的同时实现多个接口

```java
public class 类名 extends 父类 implements 接口名1, 接口名2 {}
```
## 接口中成员的特点

- 成员变量

  - 只能是常量
  - 默认修饰符:public static final

- 构造方法

  - 没有

- 成员方法

  - 只能是抽象方法

  - 默认修饰符:public abstract

    > JDK7以前:接口中只能定义抽象方法
    >
    > JDK8:接口中可以定义有方法体的方法
    >
    > JDK9:接口中可以定义私有方法

### 接口和类的关系

- 类和类

  - 单继承
  - 不能多继承
  - 多层继承

- 类和接口

  - 单实现

  - 多实现

  - 继承一个类同时实现多个接口

    > 接口中同名方法只需实现一个

- 接口和接口

  - 单继承
  - 多继承

### 接口中默认方法

格式

```java
public default 返回值类型 方法名(参数列表) {}
```

- 默认方法不是抽象方法,不强制被重写,如果重写需要去掉default关键字
- public可以省略,default不能省略
- 如果实现了多个接口,且存在相同名字的默认方法,子类必须对该方法进行重写

### 接口中静态方法

格式

```java
public static 返回值类型 方法名(参数列表) {}
```

- 静态方法只能**通过接口名调用**,不能通过实现类名或对象名调用

### 接口中私有方法

格式

普通私有方法:给默认方法服务

```java
private 返回值类型 方法名(参数列表) {}
```

静态私有方法:给静态方法服务

```java
private static 返回值类型 方法名(参数类型) {}
```

# 多态

面向对象三大特征之一

### 应用场景:

需要传入拥有同一个父类的一群子类的函数

### 定义:

同类型的对象,表现出的不同形态

表现形式

​	父类类型 对象名称 = new 子类对象;

前提:

- 有继承/实现关系
- 有父类引用指向子类对象
- 有方法重写

### 多态调用成员的特点:

变量调用:编译看左边,运行也看左边

> 编译看左边:javac编译代码的时候,会看左边的父类中有没有这个变量,有->编译成功,没有->编译失败
>
> 运行看左边:java运行代码的时候,实际获取的就是左边父类中成员变量的值

方法调用:编译看左边,运行看右边

> 编译看左边:javac编译代码的时候,会看左边的父类中有没有这个方法,有->编译成功,没有->编译失败
>
> 运行看右边:java运行代码的时候,实际上运行的是子类中的方法

理解:

成员变量:看变量类型来确定是哪个类的

成员方法:子类对方法进行重写,在虚方法表中会覆盖父类的方法

### 内存图

java先加载父类再加载子类

### 优势

- 在多态形式下,右边对象可以实现解耦合,便于扩展和维护
- 定义方法的时候,使用父类型作为参数,可以接收所有子类对象,体现多态的扩展性与遍历

### 缺点

- 无法调用子类中特有的方法

  > 解决方案:强转回子类就可以调用其独有功能
  >
  > 细节:转换转成其他类型会报错

先判断再强转

类型判断

```java
需判断的变量名 instanceof 类名;
```

- 先判断类型的正确
- 是->返回true,强转为右边类
- 否->返回false


# 内部类

### 类的五大成员:

- 属性
- 方法
- 构造方法
- 代码块
- 内部类

### 定义:

在类的内部再定义一个类

### 应用场景:

- 内部类表示的事物是外部类的一部分

- 内部类单独出现没有任何意义

### 内部类访问特点

- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须创建对象

### 分类:

- 成员内部类

  - 写在成员位置的,属于外部类的成员

  - 成员内部类可以被一些修饰符所修饰

    > private 默认 protected public static

  -  在成员内部类里面,JDK16之前不能定义静态变量,JDK16开始才可以定义静态变量
  - 获取成员内部类对象
    - 在外部类中编写方法,对外提供内部类的对象(private修饰符)
    - 直接创建格式:`外部类名.内部类名 对象名 = new 外部类对象().new 内部类对象();`(其他修饰符)
  - 获取外部类成员变量
    - `外部类名.this.变量名`

- 静态内部类

  - 用static修饰的内部类
  - 静态内部类只能访问外部类中的静态变量和静态方法
  - 创建格式`外部类名.内部类名 对象名 = new 外部类名.内部类名();`
  - 调用非静态方法:先创建对象,用对象调用
  - 调用静态方法:`外部类名.内部类名.方法名();`

- 局部内部类

  - 将内部类定义在方法里面,类似于局部变量
  - 外界无法直接使用局部内部类,需要在方法内部创建对象并使用
  - 该类可以直接访问外部类的成员,也可以访问方法内的局部变量

#### 匿名内部类

```java
new 类名或接口名(){
    重写方法;
};
```

1. 继承/实现关系

2. 方法的重写

3. 创建对象

使用场景:

- 只使用一次的对象可以使用匿名内部类进行创建

使用方式:

- 可以写在成员位置,也可以写在局部位置

- 将匿名类创建的对象赋值给自身类或父类类型变量

```java
类名或接口名或父类名 变量名 = new 类名或接口名(){
    重写方法;
};
```

- 直接在后面调用方法

```java
new 类名或接口名(){
    重写方法;
}.方法名();
```

细节:

- 匿名类是一个类的子类对象或接口的实现类对象
